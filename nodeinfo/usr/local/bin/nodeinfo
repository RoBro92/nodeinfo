#!/usr/bin/env python3

import subprocess
import sys
import datetime
import os
import re
import requests

VERSION = "0.2.8"
GITHUB_REPO = "RoBro92/nodeinfo"

if "--version" in sys.argv or "-v" in sys.argv:
    print(f"nodeinfo version {VERSION}")
    sys.exit(0)

if "--help" in sys.argv or "-h" in sys.argv:
    def print_help():
        print(f"""Usage: nodeinfo <vmid> [options]

Options:
  --version, -v     Show current nodeinfo version
  --vlan            Open VLAN name config file for editing
  update            Check for latest version and display download link
  --help, -h        Show this help message

Examples:
  nodeinfo 101             # Inspect VM/LXC with ID 101
  nodeinfo --vlan          # Edit VLAN name mappings
  nodeinfo update          # Check if a new version is available
  nodeinfo --version       # Show version number
""")
        sys.exit(0)
    print_help()


def print_version():
    print(f"nodeinfo version {VERSION}")
    sys.exit(0)


def print_help():
    print(f"""Usage: nodeinfo <vmid> [options]

Options:
  --version, -v     Show current nodeinfo version
  --vlan            Open VLAN name config file for editing
  update            Check for latest version and display download link
  --help, -h        Show this help message

Examples:
  nodeinfo 101             # Inspect VM/LXC with ID 101
  nodeinfo --vlan          # Edit VLAN name mappings
  nodeinfo update          # Check if a new version is available
  nodeinfo --version       # Show version number
""")
    sys.exit(0)


def run_cmd(cmd):
    try:
        return subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode().strip()
    except Exception:
        return "Unavailable"


def get_vm_type(vmid):
    if run_cmd(["qm", "status", vmid]) != "Unavailable":
        return "qemu"
    elif run_cmd(["pct", "status", vmid]) != "Unavailable":
        return "lxc"
    else:
        print(f"‚ùå VM/CT ID {vmid} not found.")
        sys.exit(1)


def get_hostname(vmid, vmtype):
    if vmtype == "lxc":
        return run_cmd(["pct", "exec", vmid, "--", "hostname"])
    return f"vm-{vmid}"


def get_os(vmid, vmtype):
    if vmtype == "lxc":
        output = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/os-release"])
        for line in output.splitlines():
            if line.startswith("PRETTY_NAME="):
                return line.split("=", 1)[1].strip('"')
    return "VM (OS not directly accessible)"


def get_network_info(vmid, vmtype):
    conf_path = f"/etc/pve/lxc/{vmid}.conf" if vmtype == "lxc" else f"/etc/pve/qemu-server/{vmid}.conf"
    ip = "Unknown"
    vlan = "Unknown"

    try:
        with open(conf_path, "r") as f:
            for line in f:
                if line.startswith("net0"):
                    if "ip=" in line:
                        match = re.search(r"ip=([\d\.\/]+)", line)
                        if match:
                            ip = match.group(1).split("/")[0]
                    if "tag=" in line:
                        match = re.search(r"tag=(\d+)", line)
                        if match:
                            vlan = match.group(1)
    except Exception:
        pass

    if ip == "Unknown" and vmtype == "lxc":
        try:
            ip = run_cmd(["pct", "exec", vmid, "--", "hostname", "-I"]).split()[0]
        except Exception:
            pass

    return ip, vlan


def vlan_to_name(vlan):
    config_path = "/etc/nodeinfo/vlan.conf"
    if not os.path.exists(config_path):
        return "No VLAN defined"

    try:
        with open(config_path, "r") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#") or "=" not in line:
                    continue
                tag, name = line.split("=", 1)
                if tag.strip() == vlan:
                    return name.strip()
    except Exception as e:
        print(f"‚ö†Ô∏è Error reading VLAN config: {e}")

    return "No VLAN defined"


def generate_ssh_info(vmid, vmtype):
    if vmtype != "lxc":
        return "- **SSH Access**: Unknown (non-LXC VM)"

    ssh_enabled = False
    ssh_port = "22"
    auth_method = "Unknown"
    root_login = "Unknown"

    try:
        output = run_cmd(["pct", "exec", vmid, "--", "pgrep", "-x", "sshd"])
        ssh_enabled = bool(output)
    except Exception:
        pass

    if not ssh_enabled:
        return "- **SSH Access**: Disabled"

    try:
        config = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/ssh/sshd_config"])
        password_auth = pubkey_auth = None
        for line in config.splitlines():
            line = line.strip()
            if line.startswith("Port"):
                parts = line.split()
                if len(parts) > 1:
                    ssh_port = parts[1]
            elif line.startswith("PasswordAuthentication"):
                password_auth = line.split()[1].lower()
            elif line.startswith("PubkeyAuthentication"):
                pubkey_auth = line.split()[1].lower()
            elif line.startswith("PermitRootLogin"):
                root_login = line.split()[1].lower()

        if password_auth == "yes":
            auth_method = "Password"
        elif pubkey_auth == "yes":
            auth_method = "SSH Key"
        elif password_auth == "no" and pubkey_auth == "no":
            auth_method = "Disabled"
        else:
            auth_method = "Assumed Password"

        if root_login == "no":
            root_login = "No"
        elif root_login == "yes":
            root_login = "Yes"
        else:
            root_login = "Default (Yes)"
    except Exception:
        pass

    return f"""- **SSH Access**: Enabled
- **SSH Port**: {ssh_port}
- **Auth Method**: {auth_method}
- **Allow Root Login**: {root_login}"""


def get_os_update_info(vmid, vmtype):
    if vmtype != "lxc":
        return "OS version and update info not available for VMs"

    try:
        os_info = run_cmd(["pct", "exec", vmid, "--", "lsb_release", "-d"]).split(":", 1)[1].strip()
    except Exception:
        os_info = "Unavailable"

    try:
        update_stamp = run_cmd(["pct", vmid, "exec", "--", "stat", "-c", "%y", "/var/lib/apt/periodic/update-success-stamp"])
    except Exception:
        update_stamp = "Unknown"

    try:
        upgradable = run_cmd(["pct", "exec", vmid, "--", "apt", "list", "--upgradable"])
        upgrades = upgradable.splitlines()[1:]
        if upgrades:
            upgrade_summary = f"{len(upgrades)} packages upgradable"
        else:
            upgrade_summary = "Up to date"
    except Exception:
        upgrade_summary = "Unavailable"

    return f"""- **Base OS**: {os_info}
- **Last apt update**: {update_stamp}
- **Package status**: {upgrade_summary}"""

def generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan):
    today = datetime.date.today().isoformat()
    return f"""üñ•Ô∏è **Container/VM Information**

- **Hostname**: {hostname}
- **Type**: {vmtype}
- **Operating System**: {os_name}
- **IP Address**: {ip}
- **VLAN/Subnet**: {vlan} ‚Äì {vlan_to_name(vlan)}

üîí **Access & Credentials**

- **Web UI URL**: http://{ip}
{generate_ssh_info(vmid, vmtype)}

üîÑ **Update Process**

{get_os_update_info(vmid, vmtype)}


üìù **User Notes**

*(Add any relevant notes below. This section will be preserved on updates.)*

‚ö†Ô∏è **Issues & Fixes**

| Date       | Issue         | Fix / Workaround              |
|------------|---------------|-------------------------------|
| {today} | Example issue | Description of how you fixed it |
"""


def update_notes(vmid, vmtype, markdown):
    if vmtype == "lxc":
        config_path = f"/etc/pve/lxc/{vmid}.conf"
        try:
            with open(config_path, "r") as f:
                lines = f.readlines()

            # Check if notes already exist
            existing_notes = [line for line in lines if line.startswith("#")]

            # Check if nodeinfo block is present
            has_nodeinfo = any("# === nodeinfo start ===" in line for line in lines)

            if existing_notes:
                if has_nodeinfo:
                    confirm = input("‚ö†Ô∏è A previous nodeinfo block was found. Overwrite autogenerated section? (y/N): ").strip().lower()
                else:
                    confirm = input("‚ö†Ô∏è Notes already exist in the config. Overwrite with nodeinfo data? (y/N): ").strip().lower()
                if confirm != "y":
                    print("‚ùå Update cancelled.")
                    return False

            # Extract existing nodeinfo block and preserve User Notes and Issues & Fixes sections
            start = end = None
            for i, line in enumerate(lines):
                if line.strip() == "# === nodeinfo start ===":
                    start = i
                elif line.strip() == "# === nodeinfo end ===":
                    end = i
                    break

            preserved_user_notes = []
            preserved_issues_fixes = []
            if start is not None and end is not None:
                nodeinfo_block = lines[start + 1:end]

                # Find User Notes and Issues & Fixes sections
                user_notes_start = None
                user_notes_end = None
                issues_start = None
                issues_end = None
                for idx, line in enumerate(nodeinfo_block):
                    stripped = line.strip()
                    if stripped == "# üìù **User Notes**":
                        user_notes_start = idx
                    elif stripped == "# ‚ö†Ô∏è **Issues & Fixes**":
                        issues_start = idx
                # User Notes end: before Issues or next header/blank
                if user_notes_start is not None:
                    user_notes_end = len(nodeinfo_block)
                    for i in range(user_notes_start + 1, len(nodeinfo_block)):
                        line = nodeinfo_block[i].strip()
                        if i == issues_start:
                            user_notes_end = i
                            break
                        if (line.startswith("# üñ•Ô∏è") or line.startswith("# üîí")
                                or line.startswith("# üîÑ") or line.startswith("# üìù") and i != user_notes_start
                                or line == ""):
                            if line != "# ‚ö†Ô∏è **Issues & Fixes**":
                                user_notes_end = i
                                break
                    preserved_user_notes = nodeinfo_block[user_notes_start:user_notes_end]
                # Issues & Fixes end: next header/blank
                if issues_start is not None:
                    issues_end = len(nodeinfo_block)
                    for i in range(issues_start + 1, len(nodeinfo_block)):
                        line = nodeinfo_block[i].strip()
                        if (line.startswith("# üñ•Ô∏è") or line.startswith("# üîí")
                                or line.startswith("# üîÑ") or line.startswith("# üìù") and i != issues_start
                                or line == ""):
                            issues_end = i
                            break
                    preserved_issues_fixes = nodeinfo_block[issues_start:issues_end]
                # Remove existing nodeinfo block
                del lines[start:end + 1]

            # Clean new notes and append remaining config
            new_notes = ["# === nodeinfo start ===\n"]
            for line in markdown.splitlines():
                new_notes.append(f"# {line}\n")

            # Helper to check if a section header is present in new_notes
            def section_in_markdown(header, markdown_lines):
                for l in markdown_lines:
                    if l.strip().lstrip("#").strip() == header:
                        return True
                return False

            # Fallback: If preserved User Notes/Issues sections are missing in new markdown, append them at the end (before end marker)
            # Always avoid duplicating the header line if already present.
            # 1. User Notes
            if preserved_user_notes:
                header = "üìù **User Notes**"
                # Check if header present in markdown
                if not section_in_markdown(header, new_notes):
                    # Add header and content
                    new_notes.append(f"# {header}\n")
                    new_notes.extend(preserved_user_notes[1:] if len(preserved_user_notes) > 1 else [])
                else:
                    # If header present, only add content if the markdown didn't include the preserved content
                    # (Avoid duplicate lines)
                    pass  # Already included by regeneration
            # 2. Issues & Fixes
            if preserved_issues_fixes:
                header = "‚ö†Ô∏è **Issues & Fixes**"
                if not section_in_markdown(header, new_notes):
                    new_notes.append(f"# {header}\n")
                    new_notes.extend(preserved_issues_fixes[1:] if len(preserved_issues_fixes) > 1 else [])
                else:
                    pass

            new_notes.append("# === nodeinfo end ===\n")

            # Append any remaining config lines (excluding old nodeinfo block)
            new_config = new_notes + [line for line in lines if not line.startswith("# === nodeinfo")]

            with open(config_path, "w") as f:
                f.writelines(new_config)

            print(f"‚úÖ Notes written to {config_path}")
            return True
        except Exception as e:
            print(f"‚ùå Failed to write LXC notes: {e}")
            return False
    else:
        # For QEMU, overwrite notes entirely
        subprocess.run(["qm", "set", vmid, "--notes", markdown])
        return True


def do_self_update():

    try:
        print("üîç Checking for updates on GitHub...")
        response = requests.get(f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest")
        if response.status_code != 200:
            raise Exception("GitHub API error")
        latest = response.json().get("tag_name", "").lstrip("v")

        if latest == VERSION:
            print(f"‚úÖ You are on the latest version ({VERSION})")
            return

        print(f"üì¶ New version available: {latest} (current: {VERSION})")
        confirm = input("Do you want to download and install it now? [y/N] ").strip().lower()
        if confirm != "y":
            print("‚ùå Update cancelled.")
            return

        url = f"https://github.com/{GITHUB_REPO}/releases/latest/download/nodeinfo_v{latest}.deb"
        deb_file = f"/tmp/nodeinfo_v{latest}.deb"

        print(f"‚¨áÔ∏è  Downloading {url}...")
        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            with open(deb_file, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)

        vlan_path = "/etc/nodeinfo/vlan.conf"
        backup = "/tmp/vlan.conf.bak"

        if os.path.exists(vlan_path) and os.path.getsize(vlan_path) > 0:
            print("üíæ Backing up existing VLAN config...")
            subprocess.run(["cp", vlan_path, backup])

        print("üì¶ Installing new version...")
        subprocess.run(["dpkg", "-i", deb_file])

        if os.path.exists(backup):
            print("üîÅ Restoring VLAN config...")
            subprocess.run(["cp", backup, vlan_path])
            os.remove(backup)

        print(f"‚úÖ nodeinfo updated to version {latest}")
    except Exception as e:
        print(f"‚ùå Failed to update: {e}")


def main():
    if len(sys.argv) < 2:
        print("Usage: nodeinfo <vmid> | --version | update | --vlan | --remove")
        sys.exit(1)

    if sys.argv[1] in ("--version", "-v"):
        print_version()
        return

    if sys.argv[1] in ("--help", "-h"):
        print_help()
        return

    if sys.argv[1] == "update":
        do_self_update()
        return

    if sys.argv[1] == "--vlan":
        editor = os.environ.get("EDITOR", "nano")
        config_path = "/etc/nodeinfo/vlan.conf"
        try:
            subprocess.run([editor, config_path])
        except Exception as e:
            print(f"‚ùå Failed to open VLAN config: {e}")
        return

    if sys.argv[1] == "--remove":
        confirm = input("‚ö†Ô∏è  This will completely uninstall nodeinfo and remove all its files. Continue? (y/n): ").lower()
        if confirm != 'y':
            print("‚ùå Removal cancelled.")
            return

        paths_to_remove = [
            "/usr/local/bin/nodeinfo",
            "/etc/nodeinfo",
            "/usr/local/share/nodeinfo"
        ]

        for path in paths_to_remove:
            if os.path.isfile(path):
                os.remove(path)
                print(f"üóëÔ∏è Removed file: {path}")
            elif os.path.isdir(path):
                import shutil
                shutil.rmtree(path)
                print(f"üóëÔ∏è Removed directory: {path}")

        print("‚úÖ nodeinfo successfully removed.")
        return

    vmid = sys.argv[1]
    vmtype = get_vm_type(vmid)
    hostname = get_hostname(vmid, vmtype)
    os_name = get_os(vmid, vmtype)
    ip, vlan = get_network_info(vmid, vmtype)

    markdown = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan)
    updated = update_notes(vmid, vmtype, markdown)
    if updated:
        print(f"‚úÖ Notes updated for {vmtype.upper()} ID {vmid}")


if __name__ == "__main__":
    main()