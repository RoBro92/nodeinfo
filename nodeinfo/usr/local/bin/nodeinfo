#!/usr/bin/env python3

import subprocess
import sys
import datetime
import os
import re
import requests
import json

VERSION = "1.0.8"
GITHUB_REPO = "RoBro92/nodeinfo"
SSH_CONFIG_FILE = "/etc/nodeinfo/ssh.conf"

DEBUG_FLAG_FILE = "/tmp/nodeinfo_debug"
def is_debug_enabled():
    return os.path.exists(DEBUG_FLAG_FILE)

def debug_print(msg):
    if is_debug_enabled():
        print(f"üêû {msg}")

if "--version" in sys.argv or "-v" in sys.argv:
    print(f"nodeinfo version {VERSION}")
    sys.exit(0)


def print_version():
    print(f"nodeinfo version {VERSION}")
    sys.exit(0)


def print_help():
    print(f"""Usage: nodeinfo <vmid> [options]

Options:
  --version, -v     Show current nodeinfo version
  --vlan            Open VLAN name config file for editing
  --ssh             Open SSH config file for editing
  --ssh-send        Push SSH public key to all VMs listed in SSH config
  update            Check for latest version and display download link
  --help            Show this help message
  --debug           Enable debug mode (creates {DEBUG_FLAG_FILE} file)
  --remove          Uninstall nodeinfo and remove all files
  --yes, -y         Automatically overwrite existing notes without confirmation (still prompts for backup)
  
Examples:
  nodeinfo 101             # Inspect VM/LXC with ID 101
  nodeinfo 101 -y          # Inspect VM/LXC with ID 101 and auto-overwrite notes
  nodeinfo --vlan          # Edit VLAN name mappings
  nodeinfo --ssh           # Edit SSH mappings for VMs
  nodeinfo --ssh-send      # Push SSH public key to all VMs in SSH config
  nodeinfo update          # Check if a new version is available
  nodeinfo --version       # Show version number
""")
    sys.exit(0)


def run_cmd(cmd):
    if is_debug_enabled():
        print(f"üêû Running command: {' '.join(cmd)}")
    try:
        return subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode().strip()
    except Exception:
        return "Unavailable"


def get_vm_type(vmid):
    if run_cmd(["qm", "status", vmid]) != "Unavailable":
        vmtype = "qemu"
        # QEMU Guest Agent detection
        if run_cmd(["qm", "guest", "cmd", vmid, "get-host-name"]) != "Unavailable":
            debug_print("QEMU Guest Agent detected and will be used for data collection.")
        else:
            debug_print("QEMU Guest Agent not available. Data will be limited unless SSH is configured.")
    elif run_cmd(["pct", "status", vmid]) != "Unavailable":
        vmtype = "lxc"
    else:
        print(f"‚ùå VM/CT ID {vmid} not found.")
        sys.exit(1)
    debug_print(f"VM type determined: {vmtype}")
    return vmtype


def get_hostname(vmid, vmtype):
    if vmtype == "lxc":
        hostname = run_cmd(["pct", "exec", vmid, "--", "hostname"])
    else:
        guest_hostname = run_cmd(["qm", "guest", "cmd", vmid, "get-host-name"])
        if guest_hostname != "Unavailable":
            hostname = guest_hostname.strip('"')
        else:
            hostname = f"vm-{vmid}"
    debug_print(f"Hostname: {hostname}")
    return hostname


def get_os(vmid, vmtype):
    if vmtype == "lxc":
        output = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/os-release"])
        for line in output.splitlines():
            if line.startswith("PRETTY_NAME="):
                os_name = line.split("=", 1)[1].strip('"')
                debug_print(f"OS: {os_name}")
                return os_name
        os_name = "Unknown"
        debug_print(f"OS: {os_name}")
        return os_name
    guest_osinfo = run_cmd(["qm", "guest", "cmd", vmid, "get-osinfo"])
    if guest_osinfo != "Unavailable":
        match = re.search(r'"pretty-name":\s*"([^"]+)"', guest_osinfo)
        if match:
            os_name = match.group(1)
            debug_print(f"OS: {os_name}")
            return os_name
    os_name = "VM (OS not directly accessible)"
    debug_print(f"OS: {os_name}")
    return os_name


def get_network_info(vmid, vmtype):
    conf_path = f"/etc/pve/lxc/{vmid}.conf" if vmtype == "lxc" else f"/etc/pve/qemu-server/{vmid}.conf"
    ip = "Unknown"
    vlan = "Unknown"

    try:
        with open(conf_path, "r") as f:
            for line in f:
                if line.startswith("net0"):
                    if "ip=" in line:
                        match = re.search(r"ip=([\d\.\/]+)", line)
                        if match:
                            ip = match.group(1).split("/")[0]
                    if "tag=" in line:
                        match = re.search(r"tag=(\d+)", line)
                        if match:
                            vlan = match.group(1)
    except Exception:
        pass

    if ip == "Unknown" and vmtype == "lxc":
        try:
            ip = run_cmd(["pct", "exec", vmid, "--", "hostname", "-I"]).split()[0]
        except Exception:
            pass

    # For VM, try QEMU Guest Agent for network info
    if vmtype != "lxc":
        guest_net = run_cmd(["qm", "guest", "cmd", vmid, "network-get-interfaces"])
        if guest_net != "Unavailable":
            try:
                interfaces = json.loads(guest_net)
                for iface in interfaces:
                    for ip_data in iface.get("ip-addresses", []):
                        if ip_data.get("ip-address", "").startswith("192.") or ip_data.get("ip-address", "").startswith("10."):
                            ip = ip_data["ip-address"]
                            break
                    if ip != "Unknown":
                        break
            except Exception as e:
                debug_print(f"Failed to parse guest agent network info: {e}")

    debug_print(f"IP: {ip}, VLAN: {vlan}")
    return ip, vlan


def vlan_to_name(vlan):
    config_path = "/etc/nodeinfo/vlan.conf"
    if not os.path.exists(config_path):
        return "No VLAN defined"

    try:
        with open(config_path, "r") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#") or "=" not in line:
                    continue
                tag, name = line.split("=", 1)
                if tag.strip() == vlan:
                    return name.strip()
    except Exception as e:
        print(f"‚ö†Ô∏è Error reading VLAN config: {e}")

    return "No VLAN defined"


def generate_ssh_info(vmid, vmtype):
    if os.path.exists(SSH_CONFIG_FILE):
        try:
            with open(SSH_CONFIG_FILE, "r") as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{vmid}="):
                        ssh_target = line.split("=", 1)[1].strip()
                        debug_print(f"Found SSH mapping for VMID {vmid}: {ssh_target}")
                        if ":" in ssh_target:
                            ssh_host, ssh_port = ssh_target.split(":")
                        else:
                            ssh_host = ssh_target
                            ssh_port = "22"

                        debug_print(f"Trying SSH connection to {ssh_host}:{ssh_port} using key /etc/nodeinfo/id_nodeinfo")
                        # Try connecting via SSH
                        ssh_cmd = ["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", ssh_host, "pgrep", "-x", "sshd"]
                        result = subprocess.run(ssh_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        if result.returncode != 0:
                            return "- **SSH Access**: ‚ùå Configured but unreachable"
                        debug_print("SSH connection successful.")

                        # Pull sshd_config and parse it
                        config_output = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", ssh_host, "cat /etc/ssh/sshd_config"], stderr=subprocess.DEVNULL).decode()
                        password_auth = pubkey_auth = root_login = "Unknown"

                        for line in config_output.splitlines():
                            line = line.strip()
                            if line.startswith("PasswordAuthentication"):
                                password_auth = line.split()[1].lower()
                            elif line.startswith("PubkeyAuthentication"):
                                pubkey_auth = line.split()[1].lower()
                            elif line.startswith("PermitRootLogin"):
                                root_login = line.split()[1].lower()

                        debug_print(f"Parsed SSH config:\nPasswordAuth={password_auth}, PubkeyAuth={pubkey_auth}, PermitRootLogin={root_login}")

                        if password_auth == "yes":
                            auth_method = "Password"
                        elif pubkey_auth == "yes":
                            auth_method = "SSH Key"
                        else:
                            auth_method = "Disabled"

                        return f"""- **SSH Access**: üü¢ Configured via SSH
- **SSH Host**: {ssh_host}
- **SSH Port**: {ssh_port}
- **Auth Method**: {auth_method}
- **Allow Root Login**: {root_login}"""
        except Exception as e:
            debug_print(f"Failed to fetch SSH info: {e}")

    # If not found in ssh.conf, proceed with original logic
    if vmtype != "lxc":
        return "- **SSH Access**: Unknown (non-LXC VM)"

    ssh_enabled = False
    ssh_port = "Unavailable"
    auth_method = "Unknown"
    root_login = "Unknown"

    try:
        output = run_cmd(["pct", "exec", vmid, "--", "pgrep", "-x", "sshd"])
        ssh_enabled = bool(output)
    except Exception:
        pass

    try:
        ssh_port_output = run_cmd(["pct", "exec", vmid, "--", "ss", "-tulpn"])
        match = re.search(r":(\d+)\s+.*sshd", ssh_port_output)
        if match:
            ssh_port = match.group(1)
    except Exception:
        pass

    if not ssh_enabled:
        return "- **SSH Access**: üî¥ Disabled"

    try:
        config = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/ssh/sshd_config"])
        password_auth = pubkey_auth = None
        for line in config.splitlines():
            line = line.strip()
            if line.startswith("Port"):
                parts = line.split()
                if len(parts) > 1:
                    ssh_port = parts[1]
            elif line.startswith("PasswordAuthentication"):
                password_auth = line.split()[1].lower()
            elif line.startswith("PubkeyAuthentication"):
                pubkey_auth = line.split()[1].lower()
            elif line.startswith("PermitRootLogin"):
                root_login = line.split()[1].lower()

        if password_auth == "yes":
            auth_method = "Password"
        elif pubkey_auth == "yes":
            auth_method = "SSH Key"
        elif password_auth == "no" and pubkey_auth == "no":
            auth_method = "Disabled"
        else:
            auth_method = "Assumed Password"

        if root_login == "no":
            root_login = "No"
        elif root_login == "yes":
            root_login = "Yes"
        else:
            root_login = "Default (Yes)"
    except Exception:
        pass

    ssh_status = "üü¢ Enabled"
    if ssh_port == "Unavailable" and auth_method == "Unknown" and root_login == "Unknown":
        ssh_status = "‚ùå Not Installed"

    return f"""- **SSH Access**: {ssh_status}
- **SSH Port**: {ssh_port}
- **Auth Method**: {auth_method}
- **Allow Root Login**: {root_login}"""


def get_os_update_info(vmid, vmtype):
    if vmtype != "lxc":
        return "OS version and update info not available for VMs. For full support, enable QEMU Guest Agent or provide SSH config."
    try:
        update_stamp = run_cmd(["pct", "exec", vmid, "--", "stat", "-c", "%y", "/var/lib/apt/periodic/update-success-stamp"])
    except Exception:
        try:
            update_stamp = run_cmd(["pct", "exec", vmid, "--", "stat", "-c", "%y", "/var/lib/apt/periodic/update-success-stamp"])
        except Exception:
            update_stamp = "Unavailable"

    try:
        upgradable = run_cmd(["pct", "exec", vmid, "--", "apt", "list", "--upgradable"])
        upgrades = upgradable.splitlines()[1:]
        if upgrades and any("upgradable" in line for line in upgrades):
            upgrade_summary = f"{len(upgrades)} packages upgradable"
        else:
            upgrade_summary = "Up to date"
    except Exception:
        upgrade_summary = "Unavailable"

    return f"""- **Last apt update**: {update_stamp}
- **Package status**: {upgrade_summary}"""

def generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status):
    markdown = f"""
üñ•Ô∏è **Container/VM Information**

- **Hostname**: {hostname}
- **Type**: {vmtype}
- **Operating System**: {os_name}
- **IP Address**: {ip}
- **Gateway**: {gateway}
- **Gateway Reachable**: {gateway_status}
- **DNS Servers**: {dns_servers}
- **DNS Resolving**: {dns_status}
- **VLAN/Subnet**: {vlan} ‚Äì {vlan_to_name(vlan)}

üîí **Access & Credentials**

- **Web UI URL**: http://{ip}
{generate_ssh_info(vmid, vmtype)}

üîÑ **Update Status**

{get_os_update_info(vmid, vmtype)}
"""

    markdown = re.sub(r'(?<!\n)üñ•Ô∏è', r'\nüñ•Ô∏è', markdown)
    # Optionally append VM data limitation note
    if vmtype != "lxc":
        markdown += "\n\nüìù *Note: VM data is limited. For best results, install QEMU Guest Agent or provide SSH access in /etc/nodeinfo/ssh.conf*"
    return markdown
def get_network_status(vmid, vmtype):
    gateway = "Unavailable"
    dns_servers = "Unavailable"
    gateway_status = "‚ùå Unreachable"
    dns_status = "‚ùå Failed"

    if vmtype == "lxc":
        try:
            gateway = run_cmd(["pct", "exec", vmid, "--", "ip", "route", "show", "default"]).split()[2]
            gateway_status_check = run_cmd(["pct", "exec", vmid, "--", "ping", "-c", "1", "-w", "1", gateway])
            if re.search(r"1 (packets )?received", gateway_status_check, re.IGNORECASE) or "1 received" in gateway_status_check:
                gateway_status = "‚úÖ Reachable"
            if is_debug_enabled():
                print("üîç DEBUG - Gateway ping result:\n", gateway_status_check)
        except Exception:
            pass

        try:
            resolv_conf = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/resolv.conf"])
            dns_list = []
            for line in resolv_conf.splitlines():
                if line.startswith("nameserver"):
                    dns_list.append(line.split()[1])
            if dns_list:
                dns_servers = ", ".join(dns_list)
                test_dns = run_cmd(["pct", "exec", vmid, "--", "getent", "hosts", "google.com"])
                if test_dns:
                    dns_status = "‚úÖ Resolving"
        except Exception:
            pass

    debug_print(f"Gateway: {gateway}, Reachable: {gateway_status}")
    debug_print(f"DNS Servers: {dns_servers}, Resolving: {dns_status}")
    return gateway, dns_servers, gateway_status, dns_status


def update_notes(vmid, vmtype, markdown, auto_overwrite=False):
    if vmtype == "lxc":
        config_path = f"/etc/pve/lxc/{vmid}.conf"
        debug_print("Writing notes to config file...")
        try:
            with open(config_path, "r") as f:
                content = f.read()
        except Exception as e:
            debug_print(f"Failed to write notes: {e}")
            print(f"‚ùå Failed to read config file for preservation: {e}")
            return False

        lines = content.splitlines()
        comment_lines = [line for line in lines if line.strip().startswith("#")]
        if comment_lines and not auto_overwrite:
            confirm = input("‚ö†Ô∏è Commented notes already exist in this config file. Overwrite with nodeinfo block? (y/N): ").strip().lower()
            if confirm != "y":
                print("‚ùå Update cancelled.")
                return False

        cleaned_lines = [line for line in lines if not line.strip().startswith("#")] if comment_lines else lines
        new_block_lines = []
        for line in markdown.strip().splitlines():
            new_block_lines.append(f"# {line}")
        new_content = "\n".join(cleaned_lines).rstrip()
        if new_content:
            new_content += "\n"
        new_content += "\n".join(new_block_lines) + "\n"
        try:
            with open(config_path, "w") as f:
                f.write(new_content)
            debug_print("Notes successfully written.")
            if comment_lines:
                print(f"‚úÖ Notes overwritten with nodeinfo block in {config_path}")
            else:
                print(f"‚úÖ Notes written to {config_path}")
            return True
        except Exception as e:
            debug_print(f"Failed to write notes: {e}")
            print(f"‚ùå Failed to write updated notes: {e}")
            return False
    else:
        config_path = f"/etc/pve/qemu-server/{vmid}.conf"
        try:
            with open(config_path, "r") as f:
                content = f.read()
        except Exception as e:
            debug_print(f"Failed to read VM config: {e}")
            print(f"‚ùå Failed to read VM config file: {e}")
            return False

        confirm = input("‚ö†Ô∏è Do you want to back up the original VM config file before modifying? (y/N): ").strip().lower()
        if confirm == "y":
            backup_path = f"{config_path}.bak"
            try:
                with open(backup_path, "w") as backup_file:
                    backup_file.write(content)
                print(f"üíæ Backup saved to {backup_path}")
            except Exception as e:
                debug_print(f"Backup failed: {e}")
                print(f"‚ùå Failed to write backup file: {e}")
                return False

        lines = content.splitlines()
        comment_lines = [line for line in lines if line.strip().startswith("#")]
        if comment_lines and not auto_overwrite:
            confirm = input("‚ö†Ô∏è Commented notes already exist in this VM config file. Overwrite with nodeinfo block? (y/N): ").strip().lower()
            if confirm != "y":
                print("‚ùå Update cancelled.")
                return False
        cleaned_lines = [line for line in lines if not line.strip().startswith("#")] if comment_lines else lines
        new_block_lines = []
        for line in markdown.strip().splitlines():
            new_block_lines.append(f"# {line}")
        new_content = "\n".join(cleaned_lines).rstrip()
        if new_content:
            new_content += "\n"
        new_content += "\n".join(new_block_lines) + "\n"
        try:
            with open(config_path, "w") as f:
                f.write(new_content)
            debug_print("Notes successfully written to VM config file.")
            if comment_lines:
                print(f"‚úÖ Notes overwritten with nodeinfo block in {config_path}")
            else:
                print(f"‚úÖ Notes written to {config_path}")
            return True
        except Exception as e:
            debug_print(f"Failed to write notes to VM config: {e}")
            print(f"‚ùå Failed to write updated notes to VM config: {e}")
            return False

def do_self_update():

    try:
        print("üîç Checking for updates on GitHub...")
        response = requests.get(f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest")
        if response.status_code != 200:
            raise Exception("GitHub API error")
        latest = response.json().get("tag_name", "").lstrip("v")

        if latest == VERSION:
            print(f"‚úÖ You are on the latest version ({VERSION})")
            return

        print(f"üì¶ New version available: {latest} (current: {VERSION})")
        confirm = input("Do you want to download and install it now? [y/N] ").strip().lower()
        if confirm != "y":
            print("‚ùå Update cancelled.")
            return

        url = f"https://github.com/{GITHUB_REPO}/releases/latest/download/nodeinfo_v{latest}.deb"
        deb_file = f"/tmp/nodeinfo_v{latest}.deb"

        print(f"‚¨áÔ∏è  Downloading {url}...")
        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            with open(deb_file, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)

        vlan_path = "/etc/nodeinfo/vlan.conf"
        backup = "/tmp/vlan.conf.bak"

        if os.path.exists(vlan_path) and os.path.getsize(vlan_path) > 0:
            print("üíæ Backing up existing VLAN config...")
            subprocess.run(["cp", vlan_path, backup])

        print("üì¶ Installing new version...")
        subprocess.run(["dpkg", "-i", deb_file])

        if os.path.exists(backup):
            print("üîÅ Restoring VLAN config...")
            subprocess.run(["cp", backup, vlan_path])
            os.remove(backup)

        print(f"‚úÖ nodeinfo updated to version {latest}")
    except Exception as e:
        print(f"‚ùå Failed to update: {e}")


def ensure_ssh_conf_exists():
    """Ensure SSH config file exists with instructional comments, and generate keypair if needed."""
    key_path = "/etc/nodeinfo/id_nodeinfo"
    pub_key_path = f"{key_path}.pub"

    # Generate SSH key pair if it doesn't exist
    if not os.path.exists(key_path):
        if is_debug_enabled():
            print("üêû Generating SSH keypair at /etc/nodeinfo/id_nodeinfo ...")
            subprocess.run(
                ["ssh-keygen", "-t", "rsa", "-b", "2048", "-f", key_path, "-N", ""]
            )
            debug_print(f"Generated SSH keypair at {key_path}")
        else:
            subprocess.run(
                ["ssh-keygen", "-t", "rsa", "-b", "2048", "-f", key_path, "-N", ""],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            debug_print(f"Generated SSH keypair at {key_path}")

    # Create ssh.conf with instructions if it doesn't exist
    if not os.path.exists(SSH_CONFIG_FILE):
        try:
            os.makedirs(os.path.dirname(SSH_CONFIG_FILE), exist_ok=True)
            with open(SSH_CONFIG_FILE, "w") as f:
                f.write(
"""# Format: <vmid>=<ip_or_hostname>:<port>
# Example: 105=192.168.10.45:22
# This file is used to manually define SSH access for VMs that don't support guest agent.
# The SSH private key /etc/nodeinfo/id_nodeinfo is used for authentication.
# Run the following on each VM to authorize access:
#   nodeinfo --ssh-send
# Ensure the SSH server is running and accessible on the defined ports.
# You can edit this file with your preferred text editor, e.g.:
#   nano /etc/nodeinfo/ssh.conf
# Note: If you change the SSH key, you must update this file accordingly.
"""
                )
            debug_print("Creating default SSH config file at /etc/nodeinfo/ssh.conf")
        except Exception as e:
            debug_print(f"Failed to create SSH config: {e}")

def print_debug(msg):
    if is_debug_enabled():
        print(f"üêû {msg}")

# Helper: Confirm prompt
def confirm_prompt(prompt):
    resp = input(f"{prompt} (y/N): ").strip().lower()
    return resp == "y"

# SSH-based info gathering functions
def get_gateway_via_ssh(ssh_host):
    try:
        gw = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "ip route show default"], stderr=subprocess.DEVNULL).decode()
        gateway = gw.split()[2] if "default" in gw else "Unavailable"
        ping = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "ping -c 1 -w 1 " + gateway], stderr=subprocess.DEVNULL).decode()
        reachable = "‚úÖ Reachable" if ("1 received" in ping or "1 packets received" in ping) else "‚ùå Unreachable"
        return gateway, reachable
    except Exception:
        return "Unavailable", None

def get_dns_via_ssh(ssh_host):
    try:
        resolv = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "cat /etc/resolv.conf"], stderr=subprocess.DEVNULL).decode()
        dns_list = []
        for line in resolv.splitlines():
            if line.startswith("nameserver"):
                dns_list.append(line.split()[1])
        dns_servers = ", ".join(dns_list) if dns_list else "Unavailable"
        test_dns = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "getent hosts google.com"], stderr=subprocess.DEVNULL).decode()
        dns_working = "‚úÖ Resolving" if test_dns else "‚ùå Failed"
        return dns_servers, dns_working
    except Exception:
        return "Unavailable", None

def get_update_info_via_ssh(ssh_host):
    try:
        update_stamp = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "stat -c %y /var/lib/apt/periodic/update-success-stamp"], stderr=subprocess.DEVNULL).decode().strip()
    except Exception:
        update_stamp = "Unavailable"
    try:
        upgradable = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "apt list --upgradable"], stderr=subprocess.DEVNULL).decode()
        upgrades = upgradable.splitlines()[1:]
        if upgrades and any("upgradable" in line for line in upgrades):
            upgrade_summary = f"{len(upgrades)} packages upgradable"
        else:
            upgrade_summary = "Up to date"
    except Exception:
        upgrade_summary = "Unavailable"
    return update_stamp, upgrade_summary

def get_os_info_via_ssh(ssh_host):
    try:
        output = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "cat /etc/os-release"], stderr=subprocess.DEVNULL).decode()
        for line in output.splitlines():
            if line.startswith("PRETTY_NAME="):
                return line.split("=", 1)[1].strip('"')
    except Exception:
        pass
    return None

def remove_ssh_key_and_config(host, vmid):
    """
    Remove SSH key from the VM and also remove the corresponding entry from ssh.conf.
    """
    key_path = "/root/.ssh/authorized_keys"
    PRIVATE_KEY = "/etc/nodeinfo/id_nodeinfo"
    remove_cmd = f"ssh -i {PRIVATE_KEY} -o StrictHostKeyChecking=no root@{host} \"sed -i '/nodeinfo/d' {key_path}\""
    debug_print(f"Removing SSH key from {host} using: {remove_cmd}")
    result = subprocess.run(remove_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    key_removed = result.returncode == 0
    config_removed = False
    if key_removed:
        print("üóëÔ∏è SSH key removed from VM successfully.")
        # Remove the line from SSH_CONFIG_FILE
        if os.path.exists(SSH_CONFIG_FILE):
            try:
                with open(SSH_CONFIG_FILE, "r") as f:
                    lines = f.readlines()
                new_lines = []
                for line in lines:
                    if not line.strip().startswith(f"{vmid}="):
                        new_lines.append(line)
                if len(new_lines) != len(lines):
                    with open(SSH_CONFIG_FILE, "w") as f:
                        f.writelines(new_lines)
                    config_removed = True
            except Exception as e:
                print(f"‚ö†Ô∏è Error removing SSH config entry: {e}")
    if key_removed and config_removed:
        print("üóëÔ∏è SSH config entry removed from ssh.conf.")
        debug_print(f"SSH key and config entry for VMID {vmid} removed.")
    elif key_removed:
        debug_print(f"SSH key removed from VM {host}, but config entry not found or not removed.")
    return key_removed, config_removed

def main():
    # Ensure SSH config exists at startup
    ensure_ssh_conf_exists()

    if len(sys.argv) < 2:
        print("Usage: nodeinfo <vmid> | --version | update | --vlan | --ssh | --remove")
        sys.exit(1)

    if sys.argv[1] in ("--version", "-v"):
        print_version()
        return

    if sys.argv[1] in ("--help", "-h"):
        print_help()
        return

    if sys.argv[1] == "--debug":
        if is_debug_enabled():
            os.remove(DEBUG_FLAG_FILE)
            print("üõë Debug mode disabled.")
        else:
            with open(DEBUG_FLAG_FILE, "w") as f:
                f.write("debug enabled")
            print("üêû Debug mode enabled.")
        return

    if sys.argv[1] == "update":
        do_self_update()
        return

    if sys.argv[1] == "--vlan":
        editor = os.environ.get("EDITOR", "nano")
        config_path = "/etc/nodeinfo/vlan.conf"
        try:
            subprocess.run([editor, config_path])
        except Exception as e:
            print(f"‚ùå Failed to open VLAN config: {e}")
        return

    if sys.argv[1] == "--ssh":
        # Open SSH config for editing
        editor = os.environ.get("EDITOR", "nano")
        ensure_ssh_conf_exists()
        try:
            subprocess.run([editor, SSH_CONFIG_FILE])
        except Exception as e:
            print(f"‚ùå Failed to open SSH config: {e}")
        return

    if sys.argv[1] == "--ssh-send":
        if not os.path.exists(SSH_CONFIG_FILE):
            print(f"‚ùå SSH config file not found: {SSH_CONFIG_FILE}")
            return

        key_path = "/etc/nodeinfo/id_nodeinfo.pub"
        if not os.path.exists(key_path):
            print(f"‚ùå SSH public key not found: {key_path}")
            return

        try:
            with open(SSH_CONFIG_FILE, "r") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#") or "=" not in line:
                        continue
                    vmid, ssh_target = line.split("=", 1)
                    if ":" in ssh_target:
                        ssh_host, _ = ssh_target.split(":")
                    else:
                        ssh_host = ssh_target

                    debug_print(f"Processing SSH send for VMID {vmid} -> {ssh_host}")
                    debug_print(f"Running: ssh-copy-id -i {key_path} root@{ssh_host}")
                    print(f"üîê Sending SSH key to VMID {vmid} ({ssh_host})...")
                    result = subprocess.run(["ssh-copy-id", "-i", key_path, f"root@{ssh_host}"])
                    if result.returncode == 0:
                        print(f"‚úÖ SSH key successfully copied to {ssh_host}")
                    else:
                        print(f"‚ùå Failed to copy SSH key to {ssh_host}")
        except Exception as e:
            print(f"‚ùå Error processing SSH config: {e}")
        return

    if sys.argv[1] == "--remove":
        confirm = input("‚ö†Ô∏è  This will completely uninstall nodeinfo and remove all its files. Continue? (y/n): ").lower()
        if confirm != 'y':
            print("‚ùå Removal cancelled.")
            return

        paths_to_remove = [
            "/usr/local/bin/nodeinfo",
            "/etc/nodeinfo",
            "/usr/local/share/nodeinfo"
        ]

        for path in paths_to_remove:
            if os.path.isfile(path):
                os.remove(path)
                print(f"üóëÔ∏è Removed file: {path}")
            elif os.path.isdir(path):
                import shutil
                shutil.rmtree(path)
                print(f"üóëÔ∏è Removed directory: {path}")

        print("‚úÖ nodeinfo successfully removed.")
        return

    # Argument parsing for -y/--yes flag
    auto_overwrite = False
    if "-y" in sys.argv or "--yes" in sys.argv:
        auto_overwrite = True
        debug_print("Skipping overwrite prompt due to -y flag")

    vmid = sys.argv[1]
    vmtype = get_vm_type(vmid)
    hostname = get_hostname(vmid, vmtype)
    os_name = get_os(vmid, vmtype)
    ip, vlan = get_network_info(vmid, vmtype)
    gateway, dns_servers, gateway_status, dns_status = get_network_status(vmid, vmtype)

    # --- SSH info block ---
    ssh_host = None
    ssh_port = None
    # Try to extract SSH host from config if available
    if os.path.exists(SSH_CONFIG_FILE):
        try:
            with open(SSH_CONFIG_FILE, "r") as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{vmid}="):
                        ssh_target = line.split("=", 1)[1].strip()
                        if ":" in ssh_target:
                            ssh_host, ssh_port = ssh_target.split(":")
                        else:
                            ssh_host = ssh_target
                            ssh_port = "22"
                        break
        except Exception:
            pass
    # After successful SSH connection and config parse, fetch updated system info via SSH
    if ssh_host:
        try:
            # SSH connection test
            ssh_test = subprocess.run(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", f"root@{ssh_host}", "true"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            if ssh_test.returncode == 0:
                # Fetch SSH-based info
                gateway_ssh, reachable_ssh = get_gateway_via_ssh(ssh_host)
                dns_servers_ssh, dns_working_ssh = get_dns_via_ssh(ssh_host)
                apt_last_update_ssh, package_status_ssh = get_update_info_via_ssh(ssh_host)
                os_name_ssh = get_os_info_via_ssh(ssh_host)

                print_debug(f"SSH-based OS info: {os_name_ssh}")
                print_debug(f"SSH-based Gateway: {gateway_ssh}, Reachable: {reachable_ssh}")
                print_debug(f"SSH-based DNS: {dns_servers_ssh}, Resolving: {dns_working_ssh}")
                print_debug(f"SSH-based APT: Last update {apt_last_update_ssh}, Status: {package_status_ssh}")

                # Update values for Markdown block using fetched SSH values
                if os_name_ssh:
                    os_name = os_name_ssh
                if gateway_ssh:
                    gateway = gateway_ssh
                if reachable_ssh is not None:
                    gateway_status = reachable_ssh
                if dns_servers_ssh:
                    dns_servers = dns_servers_ssh
                if dns_working_ssh is not None:
                    dns_status = dns_working_ssh
                if apt_last_update_ssh:
                    apt_last = apt_last_update_ssh
                else:
                    apt_last = None
                if package_status_ssh:
                    apt_status = package_status_ssh
                else:
                    apt_status = None
            else:
                apt_last = None
                apt_status = None
        except Exception as e:
            print_debug(f"SSH info block exception: {e}")
            apt_last = None
            apt_status = None
    else:
        apt_last = None
        apt_status = None

    # Regenerate markdown with SSH-enhanced info if available
    markdown = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status)
    updated = update_notes(vmid, vmtype, markdown, auto_overwrite=auto_overwrite)
    if updated:
        print(f"‚úÖ Notes updated for {vmtype.upper()} ID {vmid}")

    # Ensure all post-processing (qm guest cmd, etc.) is complete before offering SSH key/config removal
    # Prompt to remove SSH key and config entry after all SSH activity is finished
    if updated and ssh_host:
        if confirm_prompt("Do you want to remove the SSH key from the VM and its config entry to prevent future access and reconnection?"):
            key_removed, config_removed = remove_ssh_key_and_config(ssh_host, vmid)
            if key_removed and config_removed:
                print("‚úÖ SSH key and config entry removed. No further automatic SSH access will occur.")
            elif key_removed:
                print("‚ö†Ô∏è SSH key removed from VM, but config entry not found or not removed from ssh.conf.")
            else:
                print("‚ùå Failed to remove SSH key from VM.")

    # If VM is QEMU and SSH info is minimal, offer to attempt SSH config
    if vmtype == "qemu" and "- **SSH Access**: Unknown" in markdown:
        prompt = input(f"‚ùì SSH access is limited for VM {vmid}. Attempt to set up SSH now? (y/N): ").strip().lower()
        if prompt == "y":
            ssh_ip = ip
            ssh_entry = f"{vmid}={ssh_ip}:22"
            try:
                with open(SSH_CONFIG_FILE, "a") as f:
                    f.write(ssh_entry + "\n")
                debug_print(f"üîß Appended to SSH config: {ssh_entry}")
                subprocess.run(["ssh-copy-id", "-i", "/etc/nodeinfo/id_nodeinfo.pub", f"root@{ssh_ip}"])
                print(f"üîÅ Retesting with SSH access...")
                # Rebuild markdown and update notes
                markdown = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status)
                update_notes(vmid, vmtype, markdown, auto_overwrite=True)
            except Exception as e:
                print(f"‚ùå SSH setup failed: {e}")

    # If QEMU Guest Agent is not available, prompt for SSH access
    if vmtype == "qemu":
        guest_agent_available = run_cmd(["qm", "guest", "cmd", vmid, "get-host-name"]) != "Unavailable"
        if not guest_agent_available:
            print()
            resp = input("Would you like to enable SSH access to gather more detailed information? (y/N): ").strip().lower()
            if resp == "y":
                # Use IP from earlier, default port 22
                ssh_line = f"{vmid}={ip}:22"
                debug_print(f"Preparing to append SSH config: {ssh_line}")
                # Read current SSH config to avoid duplicates
                try:
                    exists = False
                    if os.path.exists(SSH_CONFIG_FILE):
                        with open(SSH_CONFIG_FILE, "r") as f:
                            for line in f:
                                if line.strip() == ssh_line:
                                    exists = True
                                    break
                    if not exists:
                        with open(SSH_CONFIG_FILE, "a") as f:
                            f.write(ssh_line + "\n")
                        print(f"üìÑ Added SSH config: {ssh_line}")
                        debug_print(f"Appended SSH config to {SSH_CONFIG_FILE}")
                    else:
                        debug_print("SSH config already present, skipping append.")
                except Exception as e:
                    print(f"‚ùå Failed to write to SSH config: {e}")
                    debug_print(f"Error writing SSH config: {e}")

                # --- PATCH: Prompt user before sending SSH key ---
                # Check if entry exists in SSH config
                ssh_target_line = ""
                try:
                    with open(SSH_CONFIG_FILE, "r") as f:
                        for line in f:
                            if line.strip().startswith(f"{vmid}="):
                                ssh_target_line = line.strip().split("=", 1)[1]
                                break
                except Exception as e:
                    debug_print(f"Error reading SSH config for key send: {e}")

                if ssh_target_line:
                    key_path = "/etc/nodeinfo/id_nodeinfo.pub"
                    ssh_host2 = ssh_target_line.split(":")[0]
                    # Prompt before sending SSH key
                    print("""üö® SSH Key Authentication Setup

To enable secure, passwordless access for nodeinfo, we need to send the SSH public key to the VM.

This process requires a one-time login using the root password of the VM.
After this step, nodeinfo will use SSH keys instead of passwords for future access.

You will now be prompted to enter the root password for the VM.
""")
                    proceed = input("Proceed with sending the SSH key? (y/N): ").lower()
                    if proceed != "y":
                        print("üîí SSH key send cancelled. Proceeding without SSH enhancements.")
                        return
                    if is_debug_enabled():
                        print(f"üêû Sending SSH key to {ssh_host2} using ssh-copy-id...")
                    print(f"üîê Sending SSH key to {ssh_target_line}...")
                    result = subprocess.run(["ssh-copy-id", "-i", key_path, f"root@{ssh_host2}"])
                    if is_debug_enabled():
                        print(f"üêû ssh-copy-id to {ssh_host2} returned code {result.returncode}")
                    if result.returncode == 0:
                        print(f"‚úÖ SSH key successfully copied to {ssh_host2}")
                    else:
                        print(f"‚ùå Failed to copy SSH key to {ssh_host2}")

                # Send SSH key with retries and connectivity check (if not cancelled above)
                key_path = "/etc/nodeinfo/id_nodeinfo.pub"
                ssh_target = f"root@{ip}"
                print(f"üîå Testing SSH connection to {ssh_target} before sending key...")
                ssh_test = subprocess.run(["ssh", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", ssh_target, "exit"],
                                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                if ssh_test.returncode != 0:
                    print(f"‚ùå SSH connection to {ssh_target} failed. Skipping key deployment.")
                    debug_print(f"Initial SSH connectivity test failed for {ssh_target}")
                    print(f"üí° SSH server may not be installed or running inside the VM.")
                    print("üëâ To enable SSH access, run the following inside your VM:")
                    print()
                    print("   sudo apt update && sudo apt install -y openssh-server && sudo systemctl enable ssh && sudo systemctl start ssh")
                    print()
                    print(f"üåÄ Then re-run: nodeinfo {vmid}")
                else:
                    print(f"‚úÖ SSH reachable. Proceeding to send SSH key to {ssh_target}")
                    for attempt in range(1, 4):
                        print(f"üîÅ Attempt {attempt} to send SSH key...")
                        debug_print(f"Running: ssh-copy-id -i {key_path} {ssh_target} (Attempt {attempt})")
                        result = subprocess.run(["ssh-copy-id", "-i", key_path, ssh_target], capture_output=True)
                        if result.returncode == 0:
                            print(f"‚úÖ SSH key successfully copied to {ssh_target}")
                            debug_print("SSH key copy succeeded.")
                            print("üîÑ Regenerating markdown with SSH info...")
                            debug_print("Regenerating markdown and updating notes after SSH enablement.")
                            # Re-fetch info to reflect SSH
                            markdown2 = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status)
                            update_notes(vmid, vmtype, markdown2, auto_overwrite=True)
                            break
                        else:
                            debug_print(f"ssh-copy-id attempt {attempt} failed: {result.stderr.decode().strip()}")
                            if attempt == 3:
                                print(f"‚ùå Failed to copy SSH key to {ssh_target} after 3 attempts.")


if __name__ == "__main__":
    main()