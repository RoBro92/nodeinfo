#!/usr/bin/env python3

import subprocess
import sys
import datetime
import os
import re
import requests
import json

VERSION = "1.0.6"
GITHUB_REPO = "RoBro92/nodeinfo"
SSH_CONFIG_FILE = "/etc/nodeinfo/ssh.conf"

DEBUG_FLAG_FILE = "/tmp/nodeinfo_debug"
def is_debug_enabled():
    return os.path.exists(DEBUG_FLAG_FILE)

def debug_print(msg):
    if is_debug_enabled():
        print(f"üêû {msg}")

if "--version" in sys.argv or "-v" in sys.argv:
    print(f"nodeinfo version {VERSION}")
    sys.exit(0)


def print_version():
    print(f"nodeinfo version {VERSION}")
    sys.exit(0)


def print_help():
    print(f"""Usage: nodeinfo <vmid> [options]

Options:
  --version, -v     Show current nodeinfo version
  --vlan            Open VLAN name config file for editing
  --ssh             Open SSH config file for editing
  --ssh-send        Push SSH public key to all VMs listed in SSH config
  update            Check for latest version and display download link
  --help            Show this help message
  --debug           Enable debug mode (creates {DEBUG_FLAG_FILE} file)
  --remove          Uninstall nodeinfo and remove all files
  --yes, -y         Automatically overwrite existing notes without confirmation (still prompts for backup)
  
Examples:
  nodeinfo 101             # Inspect VM/LXC with ID 101
  nodeinfo 101 -y          # Inspect VM/LXC with ID 101 and auto-overwrite notes
  nodeinfo --vlan          # Edit VLAN name mappings
  nodeinfo --ssh           # Edit SSH mappings for VMs
  nodeinfo --ssh-send      # Push SSH public key to all VMs in SSH config
  nodeinfo update          # Check if a new version is available
  nodeinfo --version       # Show version number
""")
    sys.exit(0)


def run_cmd(cmd):
    if is_debug_enabled():
        print(f"üêû Running command: {' '.join(cmd)}")
    try:
        return subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode().strip()
    except Exception:
        return "Unavailable"


def get_vm_type(vmid):
    if run_cmd(["qm", "status", vmid]) != "Unavailable":
        vmtype = "qemu"
        # QEMU Guest Agent detection
        if run_cmd(["qm", "guest", "cmd", vmid, "get-host-name"]) != "Unavailable":
            debug_print("QEMU Guest Agent detected and will be used for data collection.")
        else:
            debug_print("QEMU Guest Agent not available. Data will be limited unless SSH is configured.")
    elif run_cmd(["pct", "status", vmid]) != "Unavailable":
        vmtype = "lxc"
    else:
        print(f"‚ùå VM/CT ID {vmid} not found.")
        sys.exit(1)
    debug_print(f"VM type determined: {vmtype}")
    return vmtype


def get_hostname(vmid, vmtype):
    if vmtype == "lxc":
        hostname = run_cmd(["pct", "exec", vmid, "--", "hostname"])
    else:
        guest_hostname = run_cmd(["qm", "guest", "cmd", vmid, "get-host-name"])
        if guest_hostname != "Unavailable":
            hostname = guest_hostname.strip('"')
        else:
            hostname = f"vm-{vmid}"
    debug_print(f"Hostname: {hostname}")
    return hostname


def get_os(vmid, vmtype):
    if vmtype == "lxc":
        output = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/os-release"])
        for line in output.splitlines():
            if line.startswith("PRETTY_NAME="):
                os_name = line.split("=", 1)[1].strip('"')
                debug_print(f"OS: {os_name}")
                return os_name
        os_name = "Unknown"
        debug_print(f"OS: {os_name}")
        return os_name
    guest_osinfo = run_cmd(["qm", "guest", "cmd", vmid, "get-osinfo"])
    if guest_osinfo != "Unavailable":
        match = re.search(r'"pretty-name":\s*"([^"]+)"', guest_osinfo)
        if match:
            os_name = match.group(1)
            debug_print(f"OS: {os_name}")
            return os_name
    os_name = "VM (OS not directly accessible)"
    debug_print(f"OS: {os_name}")
    return os_name


def get_network_info(vmid, vmtype):
    conf_path = f"/etc/pve/lxc/{vmid}.conf" if vmtype == "lxc" else f"/etc/pve/qemu-server/{vmid}.conf"
    ip = "Unknown"
    vlan = "Unknown"

    try:
        with open(conf_path, "r") as f:
            for line in f:
                if line.startswith("net0"):
                    if "ip=" in line:
                        match = re.search(r"ip=([\d\.\/]+)", line)
                        if match:
                            ip = match.group(1).split("/")[0]
                    if "tag=" in line:
                        match = re.search(r"tag=(\d+)", line)
                        if match:
                            vlan = match.group(1)
    except Exception:
        pass

    if ip == "Unknown" and vmtype == "lxc":
        try:
            ip = run_cmd(["pct", "exec", vmid, "--", "hostname", "-I"]).split()[0]
        except Exception:
            pass

    # For VM, try QEMU Guest Agent for network info
    if vmtype != "lxc":
        guest_net = run_cmd(["qm", "guest", "cmd", vmid, "network-get-interfaces"])
        if guest_net != "Unavailable":
            try:
                interfaces = json.loads(guest_net)
                for iface in interfaces:
                    for ip_data in iface.get("ip-addresses", []):
                        if ip_data.get("ip-address", "").startswith("192.") or ip_data.get("ip-address", "").startswith("10."):
                            ip = ip_data["ip-address"]
                            break
                    if ip != "Unknown":
                        break
            except Exception as e:
                debug_print(f"Failed to parse guest agent network info: {e}")

    debug_print(f"IP: {ip}, VLAN: {vlan}")
    return ip, vlan


def vlan_to_name(vlan):
    config_path = "/etc/nodeinfo/vlan.conf"
    if not os.path.exists(config_path):
        return "No VLAN defined"

    try:
        with open(config_path, "r") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#") or "=" not in line:
                    continue
                tag, name = line.split("=", 1)
                if tag.strip() == vlan:
                    return name.strip()
    except Exception as e:
        print(f"‚ö†Ô∏è Error reading VLAN config: {e}")

    return "No VLAN defined"


def generate_ssh_info(vmid, vmtype):
    if os.path.exists(SSH_CONFIG_FILE):
        try:
            with open(SSH_CONFIG_FILE, "r") as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{vmid}="):
                        ssh_target = line.split("=", 1)[1].strip()
                        debug_print(f"Found SSH mapping for VMID {vmid}: {ssh_target}")
                        if ":" in ssh_target:
                            ssh_host, ssh_port = ssh_target.split(":")
                        else:
                            ssh_host = ssh_target
                            ssh_port = "22"

                        debug_print(f"Trying SSH connection to {ssh_host}:{ssh_port} using key /etc/nodeinfo/id_nodeinfo")
                        # Try connecting via SSH
                        ssh_cmd = ["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", ssh_host, "pgrep", "-x", "sshd"]
                        result = subprocess.run(ssh_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        if result.returncode != 0:
                            return "- **SSH Access**: ‚ùå Configured but unreachable"
                        debug_print("SSH connection successful.")

                        # Pull sshd_config and parse it
                        config_output = subprocess.check_output(["ssh", "-i", "/etc/nodeinfo/id_nodeinfo", ssh_host, "cat /etc/ssh/sshd_config"], stderr=subprocess.DEVNULL).decode()
                        password_auth = pubkey_auth = root_login = "Unknown"

                        for line in config_output.splitlines():
                            line = line.strip()
                            if line.startswith("PasswordAuthentication"):
                                password_auth = line.split()[1].lower()
                            elif line.startswith("PubkeyAuthentication"):
                                pubkey_auth = line.split()[1].lower()
                            elif line.startswith("PermitRootLogin"):
                                root_login = line.split()[1].lower()

                        debug_print(f"Parsed SSH config:\nPasswordAuth={password_auth}, PubkeyAuth={pubkey_auth}, PermitRootLogin={root_login}")

                        if password_auth == "yes":
                            auth_method = "Password"
                        elif pubkey_auth == "yes":
                            auth_method = "SSH Key"
                        else:
                            auth_method = "Disabled"

                        return f"""- **SSH Access**: üü¢ Configured via SSH
- **SSH Host**: {ssh_host}
- **SSH Port**: {ssh_port}
- **Auth Method**: {auth_method}
- **Allow Root Login**: {root_login}"""
        except Exception as e:
            debug_print(f"Failed to fetch SSH info: {e}")

    # If not found in ssh.conf, proceed with original logic
    if vmtype != "lxc":
        return "- **SSH Access**: Unknown (non-LXC VM)"

    ssh_enabled = False
    ssh_port = "Unavailable"
    auth_method = "Unknown"
    root_login = "Unknown"

    try:
        output = run_cmd(["pct", "exec", vmid, "--", "pgrep", "-x", "sshd"])
        ssh_enabled = bool(output)
    except Exception:
        pass

    try:
        ssh_port_output = run_cmd(["pct", "exec", vmid, "--", "ss", "-tulpn"])
        match = re.search(r":(\d+)\s+.*sshd", ssh_port_output)
        if match:
            ssh_port = match.group(1)
    except Exception:
        pass

    if not ssh_enabled:
        return "- **SSH Access**: üî¥ Disabled"

    try:
        config = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/ssh/sshd_config"])
        password_auth = pubkey_auth = None
        for line in config.splitlines():
            line = line.strip()
            if line.startswith("Port"):
                parts = line.split()
                if len(parts) > 1:
                    ssh_port = parts[1]
            elif line.startswith("PasswordAuthentication"):
                password_auth = line.split()[1].lower()
            elif line.startswith("PubkeyAuthentication"):
                pubkey_auth = line.split()[1].lower()
            elif line.startswith("PermitRootLogin"):
                root_login = line.split()[1].lower()

        if password_auth == "yes":
            auth_method = "Password"
        elif pubkey_auth == "yes":
            auth_method = "SSH Key"
        elif password_auth == "no" and pubkey_auth == "no":
            auth_method = "Disabled"
        else:
            auth_method = "Assumed Password"

        if root_login == "no":
            root_login = "No"
        elif root_login == "yes":
            root_login = "Yes"
        else:
            root_login = "Default (Yes)"
    except Exception:
        pass

    ssh_status = "üü¢ Enabled"
    if ssh_port == "Unavailable" and auth_method == "Unknown" and root_login == "Unknown":
        ssh_status = "‚ùå Not Installed"

    return f"""- **SSH Access**: {ssh_status}
- **SSH Port**: {ssh_port}
- **Auth Method**: {auth_method}
- **Allow Root Login**: {root_login}"""


def get_os_update_info(vmid, vmtype):
    if vmtype != "lxc":
        return "OS version and update info not available for VMs. For full support, enable QEMU Guest Agent or provide SSH config."
    try:
        update_stamp = run_cmd(["pct", "exec", vmid, "--", "stat", "-c", "%y", "/var/lib/apt/periodic/update-success-stamp"])
    except Exception:
        try:
            update_stamp = run_cmd(["pct", "exec", vmid, "--", "stat", "-c", "%y", "/var/lib/apt/periodic/update-success-stamp"])
        except Exception:
            update_stamp = "Unavailable"

    try:
        upgradable = run_cmd(["pct", "exec", vmid, "--", "apt", "list", "--upgradable"])
        upgrades = upgradable.splitlines()[1:]
        if upgrades and any("upgradable" in line for line in upgrades):
            upgrade_summary = f"{len(upgrades)} packages upgradable"
        else:
            upgrade_summary = "Up to date"
    except Exception:
        upgrade_summary = "Unavailable"

    return f"""- **Last apt update**: {update_stamp}
- **Package status**: {upgrade_summary}"""

def generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status):
    markdown = f"""
üñ•Ô∏è **Container/VM Information**

- **Hostname**: {hostname}
- **Type**: {vmtype}
- **Operating System**: {os_name}
- **IP Address**: {ip}
- **Gateway**: {gateway}
- **Gateway Reachable**: {gateway_status}
- **DNS Servers**: {dns_servers}
- **DNS Resolving**: {dns_status}
- **VLAN/Subnet**: {vlan} ‚Äì {vlan_to_name(vlan)}

üîí **Access & Credentials**

- **Web UI URL**: http://{ip}
{generate_ssh_info(vmid, vmtype)}

üîÑ **Update Status**

{get_os_update_info(vmid, vmtype)}
"""

    markdown = re.sub(r'(?<!\n)üñ•Ô∏è', r'\nüñ•Ô∏è', markdown)
    # Optionally append VM data limitation note
    if vmtype != "lxc":
        markdown += "\n\nüìù *Note: VM data is limited. For best results, install QEMU Guest Agent or provide SSH access in /etc/nodeinfo/ssh.conf*"
    return markdown
def get_network_status(vmid, vmtype):
    gateway = "Unavailable"
    dns_servers = "Unavailable"
    gateway_status = "‚ùå Unreachable"
    dns_status = "‚ùå Failed"

    if vmtype == "lxc":
        try:
            gateway = run_cmd(["pct", "exec", vmid, "--", "ip", "route", "show", "default"]).split()[2]
            gateway_status_check = run_cmd(["pct", "exec", vmid, "--", "ping", "-c", "1", "-w", "1", gateway])
            if re.search(r"1 (packets )?received", gateway_status_check, re.IGNORECASE) or "1 received" in gateway_status_check:
                gateway_status = "‚úÖ Reachable"
            if is_debug_enabled():
                print("üîç DEBUG - Gateway ping result:\n", gateway_status_check)
        except Exception:
            pass

        try:
            resolv_conf = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/resolv.conf"])
            dns_list = []
            for line in resolv_conf.splitlines():
                if line.startswith("nameserver"):
                    dns_list.append(line.split()[1])
            if dns_list:
                dns_servers = ", ".join(dns_list)
                test_dns = run_cmd(["pct", "exec", vmid, "--", "getent", "hosts", "google.com"])
                if test_dns:
                    dns_status = "‚úÖ Resolving"
        except Exception:
            pass

    debug_print(f"Gateway: {gateway}, Reachable: {gateway_status}")
    debug_print(f"DNS Servers: {dns_servers}, Resolving: {dns_status}")
    return gateway, dns_servers, gateway_status, dns_status


def update_notes(vmid, vmtype, markdown, auto_overwrite=False):
    if vmtype == "lxc":
        config_path = f"/etc/pve/lxc/{vmid}.conf"
        debug_print("Writing notes to config file...")
        try:
            with open(config_path, "r") as f:
                content = f.read()
        except Exception as e:
            debug_print(f"Failed to write notes: {e}")
            print(f"‚ùå Failed to read config file for preservation: {e}")
            return False

        lines = content.splitlines()
        comment_lines = [line for line in lines if line.strip().startswith("#")]
        if comment_lines and not auto_overwrite:
            confirm = input("‚ö†Ô∏è Commented notes already exist in this config file. Overwrite with nodeinfo block? (y/N): ").strip().lower()
            if confirm != "y":
                print("‚ùå Update cancelled.")
                return False

        cleaned_lines = [line for line in lines if not line.strip().startswith("#")] if comment_lines else lines
        new_block_lines = []
        for line in markdown.strip().splitlines():
            new_block_lines.append(f"# {line}")
        new_content = "\n".join(cleaned_lines).rstrip()
        if new_content:
            new_content += "\n"
        new_content += "\n".join(new_block_lines) + "\n"
        try:
            with open(config_path, "w") as f:
                f.write(new_content)
            debug_print("Notes successfully written.")
            if comment_lines:
                print(f"‚úÖ Notes overwritten with nodeinfo block in {config_path}")
            else:
                print(f"‚úÖ Notes written to {config_path}")
            return True
        except Exception as e:
            debug_print(f"Failed to write notes: {e}")
            print(f"‚ùå Failed to write updated notes: {e}")
            return False
    else:
        config_path = f"/etc/pve/qemu-server/{vmid}.conf"
        try:
            with open(config_path, "r") as f:
                content = f.read()
        except Exception as e:
            debug_print(f"Failed to read VM config: {e}")
            print(f"‚ùå Failed to read VM config file: {e}")
            return False

        confirm = input("‚ö†Ô∏è Do you want to back up the original VM config file before modifying? (y/N): ").strip().lower()
        if confirm == "y":
            backup_path = f"{config_path}.bak"
            try:
                with open(backup_path, "w") as backup_file:
                    backup_file.write(content)
                print(f"üíæ Backup saved to {backup_path}")
            except Exception as e:
                debug_print(f"Backup failed: {e}")
                print(f"‚ùå Failed to write backup file: {e}")
                return False

        lines = content.splitlines()
        comment_lines = [line for line in lines if line.strip().startswith("#")]
        if comment_lines and not auto_overwrite:
            confirm = input("‚ö†Ô∏è Commented notes already exist in this VM config file. Overwrite with nodeinfo block? (y/N): ").strip().lower()
            if confirm != "y":
                print("‚ùå Update cancelled.")
                return False
        cleaned_lines = [line for line in lines if not line.strip().startswith("#")] if comment_lines else lines
        new_block_lines = []
        for line in markdown.strip().splitlines():
            new_block_lines.append(f"# {line}")
        new_content = "\n".join(cleaned_lines).rstrip()
        if new_content:
            new_content += "\n"
        new_content += "\n".join(new_block_lines) + "\n"
        try:
            with open(config_path, "w") as f:
                f.write(new_content)
            debug_print("Notes successfully written to VM config file.")
            if comment_lines:
                print(f"‚úÖ Notes overwritten with nodeinfo block in {config_path}")
            else:
                print(f"‚úÖ Notes written to {config_path}")
            return True
        except Exception as e:
            debug_print(f"Failed to write notes to VM config: {e}")
            print(f"‚ùå Failed to write updated notes to VM config: {e}")
            return False

def do_self_update():

    try:
        print("üîç Checking for updates on GitHub...")
        response = requests.get(f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest")
        if response.status_code != 200:
            raise Exception("GitHub API error")
        latest = response.json().get("tag_name", "").lstrip("v")

        if latest == VERSION:
            print(f"‚úÖ You are on the latest version ({VERSION})")
            return

        print(f"üì¶ New version available: {latest} (current: {VERSION})")
        confirm = input("Do you want to download and install it now? [y/N] ").strip().lower()
        if confirm != "y":
            print("‚ùå Update cancelled.")
            return

        url = f"https://github.com/{GITHUB_REPO}/releases/latest/download/nodeinfo_v{latest}.deb"
        deb_file = f"/tmp/nodeinfo_v{latest}.deb"

        print(f"‚¨áÔ∏è  Downloading {url}...")
        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            with open(deb_file, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)

        vlan_path = "/etc/nodeinfo/vlan.conf"
        backup = "/tmp/vlan.conf.bak"

        if os.path.exists(vlan_path) and os.path.getsize(vlan_path) > 0:
            print("üíæ Backing up existing VLAN config...")
            subprocess.run(["cp", vlan_path, backup])

        print("üì¶ Installing new version...")
        subprocess.run(["dpkg", "-i", deb_file])

        if os.path.exists(backup):
            print("üîÅ Restoring VLAN config...")
            subprocess.run(["cp", backup, vlan_path])
            os.remove(backup)

        print(f"‚úÖ nodeinfo updated to version {latest}")
    except Exception as e:
        print(f"‚ùå Failed to update: {e}")


def ensure_ssh_conf_exists():
    """Ensure SSH config file exists with instructional comments, and generate keypair if needed."""
    key_path = "/etc/nodeinfo/id_nodeinfo"
    pub_key_path = f"{key_path}.pub"

    # Generate SSH key pair if it doesn't exist
    if not os.path.exists(key_path):
        subprocess.run(["ssh-keygen", "-t", "rsa", "-b", "2048", "-f", key_path, "-N", ""], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        debug_print(f"Generated SSH keypair at {key_path}")

    # Create ssh.conf with instructions if it doesn't exist
    if not os.path.exists(SSH_CONFIG_FILE):
        try:
            os.makedirs(os.path.dirname(SSH_CONFIG_FILE), exist_ok=True)
            with open(SSH_CONFIG_FILE, "w") as f:
                f.write(
"""# Format: <vmid>=<ip_or_hostname>:<port>
# Example: 105=192.168.10.45:22
# This file is used to manually define SSH access for VMs that don't support guest agent.
# The SSH private key /etc/nodeinfo/id_nodeinfo is used for authentication.
# Run the following on each VM to authorize access:
#   nodeinfo --ssh-send
# Ensure the SSH server is running and accessible on the defined ports.
# You can edit this file with your preferred text editor, e.g.:
#   nano /etc/nodeinfo/ssh.conf
# Note: If you change the SSH key, you must update this file accordingly.
"""
                )
            debug_print("Creating default SSH config file at /etc/nodeinfo/ssh.conf")
        except Exception as e:
            debug_print(f"Failed to create SSH config: {e}")

def main():
    # Ensure SSH config exists at startup
    ensure_ssh_conf_exists()

    if len(sys.argv) < 2:
        print("Usage: nodeinfo <vmid> | --version | update | --vlan | --ssh | --remove")
        sys.exit(1)

    if sys.argv[1] in ("--version", "-v"):
        print_version()
        return

    if sys.argv[1] in ("--help", "-h"):
        print_help()
        return

    if sys.argv[1] == "--debug":
        if is_debug_enabled():
            os.remove(DEBUG_FLAG_FILE)
            print("üõë Debug mode disabled.")
        else:
            with open(DEBUG_FLAG_FILE, "w") as f:
                f.write("debug enabled")
            print("üêû Debug mode enabled.")
        return

    if sys.argv[1] == "update":
        do_self_update()
        return

    if sys.argv[1] == "--vlan":
        editor = os.environ.get("EDITOR", "nano")
        config_path = "/etc/nodeinfo/vlan.conf"
        try:
            subprocess.run([editor, config_path])
        except Exception as e:
            print(f"‚ùå Failed to open VLAN config: {e}")
        return

    if sys.argv[1] == "--ssh":
        # Open SSH config for editing
        editor = os.environ.get("EDITOR", "nano")
        ensure_ssh_conf_exists()
        try:
            subprocess.run([editor, SSH_CONFIG_FILE])
        except Exception as e:
            print(f"‚ùå Failed to open SSH config: {e}")
        return

    if sys.argv[1] == "--ssh-send":
        if not os.path.exists(SSH_CONFIG_FILE):
            print(f"‚ùå SSH config file not found: {SSH_CONFIG_FILE}")
            return

        key_path = "/etc/nodeinfo/id_nodeinfo.pub"
        if not os.path.exists(key_path):
            print(f"‚ùå SSH public key not found: {key_path}")
            return

        try:
            with open(SSH_CONFIG_FILE, "r") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#") or "=" not in line:
                        continue
                    vmid, ssh_target = line.split("=", 1)
                    if ":" in ssh_target:
                        ssh_host, _ = ssh_target.split(":")
                    else:
                        ssh_host = ssh_target

                    debug_print(f"Processing SSH send for VMID {vmid} -> {ssh_host}")
                    debug_print(f"Running: ssh-copy-id -i {key_path} root@{ssh_host}")
                    print(f"üîê Sending SSH key to VMID {vmid} ({ssh_host})...")
                    result = subprocess.run(["ssh-copy-id", "-i", key_path, f"root@{ssh_host}"])
                    if result.returncode == 0:
                        print(f"‚úÖ SSH key successfully copied to {ssh_host}")
                    else:
                        print(f"‚ùå Failed to copy SSH key to {ssh_host}")
        except Exception as e:
            print(f"‚ùå Error processing SSH config: {e}")
        return

    if sys.argv[1] == "--remove":
        confirm = input("‚ö†Ô∏è  This will completely uninstall nodeinfo and remove all its files. Continue? (y/n): ").lower()
        if confirm != 'y':
            print("‚ùå Removal cancelled.")
            return

        paths_to_remove = [
            "/usr/local/bin/nodeinfo",
            "/etc/nodeinfo",
            "/usr/local/share/nodeinfo"
        ]

        for path in paths_to_remove:
            if os.path.isfile(path):
                os.remove(path)
                print(f"üóëÔ∏è Removed file: {path}")
            elif os.path.isdir(path):
                import shutil
                shutil.rmtree(path)
                print(f"üóëÔ∏è Removed directory: {path}")

        print("‚úÖ nodeinfo successfully removed.")
        return

    # Argument parsing for -y/--yes flag
    auto_overwrite = False
    if "-y" in sys.argv or "--yes" in sys.argv:
        auto_overwrite = True
        debug_print("Skipping overwrite prompt due to -y flag")

    vmid = sys.argv[1]
    vmtype = get_vm_type(vmid)
    hostname = get_hostname(vmid, vmtype)
    os_name = get_os(vmid, vmtype)
    ip, vlan = get_network_info(vmid, vmtype)
    gateway, dns_servers, gateway_status, dns_status = get_network_status(vmid, vmtype)

    markdown = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status)
    updated = update_notes(vmid, vmtype, markdown, auto_overwrite=auto_overwrite)
    if updated:
        print(f"‚úÖ Notes updated for {vmtype.upper()} ID {vmid}")

    # If VM is QEMU and SSH info is minimal, offer to attempt SSH config
    if vmtype == "qemu" and "- **SSH Access**: Unknown" in markdown:
        prompt = input(f"‚ùì SSH access is limited for VM {vmid}. Attempt to set up SSH now? (y/N): ").strip().lower()
        if prompt == "y":
            ssh_ip = ip
            ssh_entry = f"{vmid}={ssh_ip}:22"
            try:
                with open(SSH_CONFIG_FILE, "a") as f:
                    f.write(ssh_entry + "\n")
                debug_print(f"üîß Appended to SSH config: {ssh_entry}")
                subprocess.run(["ssh-copy-id", "-i", "/etc/nodeinfo/id_nodeinfo.pub", f"root@{ssh_ip}"])
                print(f"üîÅ Retesting with SSH access...")
                # Rebuild markdown and update notes
                markdown = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status)
                update_notes(vmid, vmtype, markdown, auto_overwrite=True)
            except Exception as e:
                print(f"‚ùå SSH setup failed: {e}")

    # If QEMU Guest Agent is not available, prompt for SSH access
    if vmtype == "qemu":
        guest_agent_available = run_cmd(["qm", "guest", "cmd", vmid, "get-host-name"]) != "Unavailable"
        if not guest_agent_available:
            print()
            resp = input("Would you like to enable SSH access to gather more detailed information? (y/N): ").strip().lower()
            if resp == "y":
                # Use IP from earlier, default port 22
                ssh_line = f"{vmid}={ip}:22"
                debug_print(f"Preparing to append SSH config: {ssh_line}")
                # Read current SSH config to avoid duplicates
                try:
                    exists = False
                    if os.path.exists(SSH_CONFIG_FILE):
                        with open(SSH_CONFIG_FILE, "r") as f:
                            for line in f:
                                if line.strip() == ssh_line:
                                    exists = True
                                    break
                    if not exists:
                        with open(SSH_CONFIG_FILE, "a") as f:
                            f.write(ssh_line + "\n")
                        print(f"üìÑ Added SSH config: {ssh_line}")
                        debug_print(f"Appended SSH config to {SSH_CONFIG_FILE}")
                    else:
                        debug_print("SSH config already present, skipping append.")
                except Exception as e:
                    print(f"‚ùå Failed to write to SSH config: {e}")
                    debug_print(f"Error writing SSH config: {e}")

                # --- BEGIN PATCH: Automatically send key if entry present in SSH config ---
                # Check if entry exists in SSH config
                ssh_target_line = ""
                try:
                    with open(SSH_CONFIG_FILE, "r") as f:
                        for line in f:
                            if line.strip().startswith(f"{vmid}="):
                                ssh_target_line = line.strip().split("=", 1)[1]
                                break
                except Exception as e:
                    debug_print(f"Error reading SSH config for key send: {e}")

                if ssh_target_line:
                    print(f"üîê Sending SSH key to {ssh_target_line}...")
                    key_path = "/etc/nodeinfo/id_nodeinfo.pub"
                    ssh_host = ssh_target_line.split(":")[0]
                    result = subprocess.run(["ssh-copy-id", "-i", key_path, f"root@{ssh_host}"])
                    if result.returncode == 0:
                        print(f"‚úÖ SSH key successfully copied to {ssh_host}")
                    else:
                        print(f"‚ùå Failed to copy SSH key to {ssh_host}")
                # --- END PATCH ---

                # Send SSH key with retries and connectivity check
                key_path = "/etc/nodeinfo/id_nodeinfo.pub"
                ssh_target = f"root@{ip}"
                print(f"üîå Testing SSH connection to {ssh_target} before sending key...")
                ssh_test = subprocess.run(["ssh", "-o", "BatchMode=yes", "-o", "ConnectTimeout=3", ssh_target, "exit"],
                                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                if ssh_test.returncode != 0:
                    print(f"‚ùå SSH connection to {ssh_target} failed. Skipping key deployment.")
                    debug_print(f"Initial SSH connectivity test failed for {ssh_target}")
                    print(f"üí° SSH server may not be installed or running inside the VM.")
                    print("üëâ To enable SSH access, run the following inside your VM:")
                    print()
                    print("   sudo apt update && sudo apt install -y openssh-server && sudo systemctl enable ssh && sudo systemctl start ssh")
                    print()
                    print(f"üåÄ Then re-run: nodeinfo {vmid}")
                else:
                    print(f"‚úÖ SSH reachable. Proceeding to send SSH key to {ssh_target}")
                    for attempt in range(1, 4):
                        print(f"üîÅ Attempt {attempt} to send SSH key...")
                        debug_print(f"Running: ssh-copy-id -i {key_path} {ssh_target} (Attempt {attempt})")
                        result = subprocess.run(["ssh-copy-id", "-i", key_path, ssh_target], capture_output=True)
                        if result.returncode == 0:
                            print(f"‚úÖ SSH key successfully copied to {ssh_target}")
                            debug_print("SSH key copy succeeded.")
                            print("üîÑ Regenerating markdown with SSH info...")
                            debug_print("Regenerating markdown and updating notes after SSH enablement.")
                            # Re-fetch info to reflect SSH
                            markdown2 = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan, gateway, dns_servers, gateway_status, dns_status)
                            update_notes(vmid, vmtype, markdown2, auto_overwrite=True)
                            break
                        else:
                            debug_print(f"ssh-copy-id attempt {attempt} failed: {result.stderr.decode().strip()}")
                            if attempt == 3:
                                print(f"‚ùå Failed to copy SSH key to {ssh_target} after 3 attempts.")


if __name__ == "__main__":
    main()