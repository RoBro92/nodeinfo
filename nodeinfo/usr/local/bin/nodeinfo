#!/usr/bin/env python3

import subprocess
import sys
import datetime
import os
import re

VERSION = "0.1.7"
GITHUB_REPO = "RoBro92/nodeinfo"


def print_version():
    print(f"nodeinfo version {VERSION}")
    sys.exit(0)


if "--version" in sys.argv or "-v" in sys.argv:
    print_version()


def run_cmd(cmd):
    try:
        return subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode().strip()
    except:
        return "Unavailable"


def get_vm_type(vmid):
    if run_cmd(["qm", "status", vmid]) != "Unavailable":
        return "qemu"
    elif run_cmd(["pct", "status", vmid]) != "Unavailable":
        return "lxc"
    else:
        print(f"‚ùå VM/CT ID {vmid} not found.")
        sys.exit(1)


def get_hostname(vmid, vmtype):
    if vmtype == "lxc":
        return run_cmd(["pct", "exec", vmid, "--", "hostname"])
    return f"vm-{vmid}"


def get_os(vmid, vmtype):
    if vmtype == "lxc":
        output = run_cmd(["pct", "exec", vmid, "--", "cat", "/etc/os-release"])
        for line in output.splitlines():
            if line.startswith("PRETTY_NAME="):
                return line.split("=")[1].strip('"')
    return "VM (OS not directly accessible)"


def get_network_info(vmid, vmtype):
    conf_path = f"/etc/pve/lxc/{vmid}.conf" if vmtype == "lxc" else f"/etc/pve/qemu-server/{vmid}.conf"
    ip = "Unknown"
    vlan = "Unknown"

    try:
        with open(conf_path, "r") as f:
            for line in f:
                if line.startswith("net0"):
                    if "ip=" in line:
                        match = re.search(r"ip=([\d\.\/]+)", line)
                        if match:
                            ip = match.group(1).split("/")[0]
                    if "tag=" in line:
                        match = re.search(r"tag=(\d+)", line)
                        if match:
                            vlan = match.group(1)
    except:
        pass

    if ip == "Unknown":
        try:
            ip = run_cmd(["pct", "exec", vmid, "--", "hostname", "-I"]).split()[0]
        except:
            pass

    return ip, vlan


def vlan_to_name(vlan):
    mapping = {
        "9": "Infrastructure",
        "10": "Hypervisors",
        "20": "Media",
    }
    return mapping.get(vlan, "Unknown")


def generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan):
    today = datetime.date.today().isoformat()
    return f"""üñ•Ô∏è **Container/VM Information**

- **Hostname**: {hostname}
- **Type**: {vmtype}
- **Operating System**: {os_name}
- **IP Address**: {ip}
- **VLAN/Subnet**: {vlan} ‚Äì {vlan_to_name(vlan)}

üîí **Access & Credentials**

- **Web UI URL**: http://{ip}
- **SSH Access**: Enabled
  - **SSH Port**: 22
  - **SSH Key Auth**: Check sshd_config

üîÑ **Update Process**

- **Service Update Method**: 
- **Last Update**: {today}
- **Update Notes**: *(e.g. manual restart required after update)*

‚ö†Ô∏è **Issues & Fixes**

| Date       | Issue         | Fix / Workaround              |
|------------|---------------|-------------------------------|
| {today} | Example issue | Description of how you fixed it |
"""


def update_notes(vmid, vmtype, markdown):
    if vmtype == "lxc":
        config_path = f"/etc/pve/lxc/{vmid}.conf"
        try:
            with open(config_path, "r") as f:
                lines = f.readlines()

            start = end = None
            for i, line in enumerate(lines):
                if line.strip() == "# === nodeinfo start ===":
                    start = i
                elif line.strip() == "# === nodeinfo end ===":
                    end = i
                    break

            if start is not None and end is not None:
                del lines[start:end + 1]

            new_notes = [f"# {line}\n" for line in markdown.splitlines()]
            new_config = new_notes + lines

            with open(config_path, "w") as f:
                f.writelines(new_config)

            print(f"‚úÖ Notes written to {config_path}")
        except Exception as e:
            print(f"‚ùå Failed to write LXC notes: {e}")
    else:
        subprocess.run(["qm", "set", vmid, "--notes", markdown])


def do_self_update():
    try:
        import requests
    except ImportError:
        print("‚ùå 'requests' module not available. Install with 'pip install requests'")
        return

    try:
        print("üîç Checking for updates on GitHub...")
        response = requests.get(f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest")
        if response.status_code != 200:
            raise Exception("GitHub API error")
        latest = response.json()["tag_name"].lstrip("v")

        if latest != VERSION:
            print(f"üì¶ New version available: {latest} (current: {VERSION})")
            print("üîó Download: https://github.com/{}/releases/latest/download/nodeinfo_v{}.deb".format(GITHUB_REPO, latest))
        else:
            print(f"‚úÖ You are on the latest version ({VERSION})")
    except Exception as e:
        print(f"‚ùå Failed to check for updates: {e}")


def main():
    if len(sys.argv) < 2:
        print("Usage: nodeinfo <vmid> | --version | update")
        sys.exit(1)

    if sys.argv[1] == "update":
        do_self_update()
        return

    vmid = sys.argv[1]
    vmtype = get_vm_type(vmid)
    hostname = get_hostname(vmid, vmtype)
    os_name = get_os(vmid, vmtype)
    ip, vlan = get_network_info(vmid, vmtype)

    markdown = generate_markdown(vmid, vmtype, hostname, os_name, ip, vlan)
    update_notes(vmid, vmtype, markdown)
    print(f"‚úÖ Notes updated for {vmtype.upper()} ID {vmid}")


if __name__ == "__main__":
    main()